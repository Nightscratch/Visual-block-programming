<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: block.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: block.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { dragElement } from "./drag";
import blockStyle from "./blockStyle/index";
import deepClone from './deepClone'
import { zoom } from "./zoom";
import * as compiler from './compiler'
import * as file from './file'

/** @constant { Number } blockMinSpace 积木连接最小距离*/
const blockMinSpace = 20
/** @constant { HTMLElement } codeSpace 积木编程区 html 对象 */
var codeSpace = null;
/** @constant { object } blocksData 存储积木数据 */
var blocksData = {};
/** @constant { object } menu 存储菜单数据 */
var menu = {};
/** @constant { HTMLElement } menuDom 菜单 html 对象 */
var menuDom = null;

/**
 * @function getMinChild 获取积木输入框的最子元素
 * @param { Number } targetBlockId 积木Id 
 * @param { String } inputId 输入名
 * @returns { Number } 最子元素Id
 */
export const getMinChild = (targetBlockId, inputId) => {
    let child = targetBlockId
    while (blocksData[child].inputs[inputId].value) {
        child = blocksData[child].inputs[inputId].value.data
    }
    return Number(child)
}

/**
 * @function setDragOut 设置积木从父积木里拖出来事件
 * @param { Number } selfBlockId 积木 Id 
 * @param { String } prentId 父积木 Id
 * @param { String } targetBlockInputIndex 输入名
 */
export const setDragOut = (e, selfBlockId, prentId, targetBlockInputIndex) => {
    if (e.target.getAttribute('blockid') != selfBlockId &amp;&amp; e.target.getAttribute('dragId') != selfBlockId) {
        return true;
    }
    e = e || window.e;
    e.preventDefault();
    if (e.button == 2) {
        return null;
    }

    delete blocksData[selfBlockId].prent
    let selfBlockDom = codeSpace.querySelector(`[blockid="${selfBlockId}"]`)
    blocksData[prentId].inputs[targetBlockInputIndex].value = null
    selfBlockDom.style.top = setPostiton(selfBlockDom, 'y') + "px";
    selfBlockDom.style.left = setPostiton(selfBlockDom, 'x') + "px";
    selfBlockDom.setAttribute('class', 'block')
    codeSpace.appendChild(selfBlockDom)
    dragElement(selfBlockDom, connectBlocks, e)
}

/**
 * @function setContext 设置积木右键菜单事件
 * @param { Number } e 事件对象
 * @param { String } domId 积木 Id
 */
export const setContext = (e, domId) => {
    e = e || window.e;
    e.preventDefault();
    if (e.target.getAttribute('blockid') != domId &amp;&amp; e.target.getAttribute('dragId') != domId) {
        return null;
    }
    debugger
    //let menuDom = menuDom//document.getElementById('menu')
    menuDom.style.display = 'block'
    menuDom.style.top = (e.clientY + 5) + "px";
    menuDom.style.left = (e.clientX + 10) + "px";
    menu.open = true
    menu.target = {
        type: 1,
        data: String(domId)
    }
}

/**
 * @function connectBlocks 检查积木可否连接其他积木并连接
 * @param { Number } dragBlockId 积木Id
 */
export const connectBlocks = (dragBlockId) => {
    let NowCanConnectBlocks = []
    let dragBlockDom = getBlockById(dragBlockId)
    for (let targetBlockId in blocksData) {
        let targetBlockData = blocksData[targetBlockId]
        if (targetBlockId == dragBlockId || !targetBlockData.defaultInput) {
            continue
        }
        for (const dragBlockInputId in blocksData[dragBlockId].inputs) {
            if (blocksData[dragBlockId].inputs[dragBlockInputId].type == 1 &amp;&amp; !blocksData[targetBlockId].prent) {
                let targetBlockDom = getBlockById(targetBlockId)
                let dragBlockInputDom = document.querySelector(`[prentId="${dragBlockId}"][inputId="${dragBlockInputId}"]`)
                let distanceX = Math.abs(targetBlockDom.getBoundingClientRect().left - dragBlockInputDom.getBoundingClientRect().left)
                let distanceY = Math.abs(targetBlockDom.getBoundingClientRect().top - dragBlockInputDom.getBoundingClientRect().top)
                let type = 1

                if (distanceY &lt; blockMinSpace &amp;&amp; distanceX &lt; blockMinSpace) {
                    NowCanConnectBlocks.push({
                        distance: distanceX + distanceY,
                        targetBlockId,
                        targetBlockDom,
                        dragBlockInputId,
                        type
                    })
                }
            }

        }
        for (const targetBlockInputIndex in targetBlockData.inputs) {
            if (!blocksData[dragBlockId].defaultInput &amp;&amp; targetBlockData.inputs[targetBlockInputIndex].type == 1) {
                continue
            }
            let targetBlockInputDom = document.querySelector(`[prentId="${targetBlockId}"][inputId="${targetBlockInputIndex}"]`)
            let distanceX = Math.abs(targetBlockInputDom.getBoundingClientRect().left - dragBlockDom.getBoundingClientRect().left)
            let distanceY = Math.abs(targetBlockInputDom.getBoundingClientRect().top - dragBlockDom.getBoundingClientRect().top)
            if (distanceX &lt; blockMinSpace &amp;&amp; distanceY &lt; blockMinSpace) {
                NowCanConnectBlocks.push({
                    distance: distanceX + distanceY,
                    targetBlockId,
                    targetBlockInputIndex,
                    targetBlockInputDom,
                    type: 0
                })
            }
        }
    }

    if (NowCanConnectBlocks.length == 0) {
        return null
    }
    NowCanConnectBlocks.sort((a, b) => {
        return a.distance - b.distance
    });
    let NowCanConnectBlock = NowCanConnectBlocks[0]

    if (NowCanConnectBlock.type == 0) {
        let {
            targetBlockId,
            targetBlockInputIndex,
            targetBlockInputDom,
        } = NowCanConnectBlock

        if (blocksData[targetBlockId].inputs[targetBlockInputIndex].value) {
            let oldBlockId = blocksData[targetBlockId].inputs[targetBlockInputIndex].value.data
            let oldBlockDom = getBlockById(oldBlockId)
            let minChildId = getMinChild(dragBlockId, 'next')


            if (targetBlockInputIndex == 'next') {

                console.log(blocksData[targetBlockId].inputs[Object.keys(blocksData[targetBlockId].inputs)[0]])
                debugger
                let defaultInput = blocksData[dragBlockId].defaultInput
                let inpid = defaultInput
                document.querySelector(`[prentId="${minChildId}"][inputId="${inpid}"]`).appendChild(oldBlockDom)
                blocksData[minChildId].inputs[inpid].value = { data: oldBlockId, type: 1 }

                blocksData[targetBlockId].inputs[targetBlockInputIndex].value = null
                blocksData[oldBlockId].prent = {
                    inputId: targetBlockInputIndex,
                    blockId: minChildId
                }
                oldBlockDom.onmousedown = (e) => {
                    setDragOut(e, oldBlockId, minChildId, targetBlockInputIndex)
                }
            } else {
                let inpid = 'next'
                document.querySelector(`[prentId="${minChildId}"][inputId="${inpid}"]`).appendChild(oldBlockDom)
                blocksData[minChildId].inputs[inpid].value = { data: oldBlockId, type: 1 }

                blocksData[oldBlockId].prent = {
                    inputId: inpid,
                    blockId: minChildId
                }
                oldBlockDom.onmousedown = (e) => {
                    setDragOut(e, oldBlockId, minChildId, inpid)
                }
            }
        }
        blocksData[targetBlockId].inputs[targetBlockInputIndex].value = {
            type: 1,
            data: dragBlockId
        }
        blocksData[dragBlockId].prent = {
            blockId: targetBlockId,
            inputId: targetBlockInputIndex
        }

        targetBlockInputDom.appendChild(dragBlockDom)
        dragBlockDom.setAttribute('class', 'block-input')
        dragBlockDom.onmousedown = (e) => {
            setDragOut(e, dragBlockId, targetBlockId, targetBlockInputIndex)
        }
    } else if (NowCanConnectBlock.type == 1) {
        let {
            targetBlockId,
            targetBlockDom,
            dragBlockInputId
        } = NowCanConnectBlock
        let dragBlockInputDom = document.querySelector(`[prentId="${dragBlockId}"][inputId="${dragBlockInputId}"]`)
        debugger
        dragBlockInputDom.append(targetBlockDom)

        blocksData[targetBlockId].prent = {
            blockId: dragBlockId,
            inputId: dragBlockInputId
        }
        blocksData[dragBlockId].inputs[dragBlockInputId].value = {
            type: 1,
            data: targetBlockId
        }
        targetBlockDom.setAttribute('class', 'block-input')
        targetBlockDom.onmousedown = (e) => {
            setDragOut(e, targetBlockId, dragBlockId, dragBlockInputId)
        }
        debugger

    }


    return null
}
/**
 * @function createBlockDomById 创建一个积木
 * @param { String } type 积木类型
 * @param { Number } dragBlockId 积木Id
 */
const createBlockDomById = (type, id) => {
    let dom = document.createElement("div");
    dom.setAttribute('blockId', `${id}`)
    dom.setAttribute('class', 'block')
    dom.innerHTML = blockStyle[type].html(id)
    return dom
}
/**
 * 创建一个积木
 * @function createBlockDom 创建一个积木
 * @param { String } type 积木类型
 * @return { HTMLDivElement } 创建积木
 */
const createBlockDom = (type) => {
    let dom = document.createElement("div");
    dom.setAttribute('blockId', `${Object.keys(blocksData).length}`)
    dom.setAttribute('class', 'block')
    dom.innerHTML = blockStyle[type].html(Object.keys(blocksData).length)
    return dom
}

/**
 * 创建一个有父的积木
 * @param { String } type 积木类型
 * @param { String } id 积木 id
 */
export const addInputBlock = (type, id = Object.keys(blocksData).length) => {
    let dom = createBlockDomById(type, id)
    dom.setAttribute('class', 'input-block')
    return dom
}

export const addBlock = (type = 'move', changeBlocksData = true, id) => {
    debugger
    let dom;
    if (!changeBlocksData) {
        dom = createBlockDomById(type, id)
    } else {
        dom = createBlockDom(type)
    }
    codeSpace.appendChild(dom);
    if (changeBlocksData) {


        dragElement(dom, connectBlocks)
        let domId = Object.keys(blocksData).length
        dom.oncontextmenu = (e) => {
            setContext(e, domId)
        }

        blocksData[domId] =
        {
            type,
            inputs: blockStyle[type].inputs(),
            isTopLevel: blockStyle[type].isTopLevel,
            defaultInput: blockStyle[type].defaultInput
        }
    }
    return dom

}

/**
 * @function getAllChildBlock 获取该积木的所有子
 * @param { Number } tagetBlockId 积木id
 * @return { number[] } 子积木id
 */
export const getAllChildBlock = (tagetBlockId) => {
    let res = []
    for (const inputKey in blocksData[tagetBlockId].inputs) {
        let inputData = blocksData[tagetBlockId].inputs[inputKey]
        if (inputData.value) {
            if (inputData.value) {

                res.push(inputData.value.data)
                res = res.concat(getAllChildBlock(inputData.value.data))

            }
        }
    }
    return res
}

/**
 * @function deletBlock 删除积木
 * @param { Number } deletBlock 积木 id
 */
export const deletBlock = (targetBlockId) => {
    getBlockById(targetBlockId).remove()

    if (blocksData[targetBlockId].prent) {
        blocksData[blocksData[targetBlockId].prent.blockId].inputs[blocksData[targetBlockId].prent.inputId].value = null
    }

    let data = getAllChildBlock(targetBlockId)
    for (const delBlockId of data) {
        delete blocksData[delBlockId]
    }
    delete blocksData[targetBlockId]
}

/**
 * @function setPostiton 通过在页面的绝对位置设置位置偏移
 * @param { Number } deletBlock 积木 id
 * @param { String } attribute 方向
 * @param { HTMLElement } dom 积木对象
 */
const setPostiton = (dom, attribute) => {
    if (attribute == 'x') {
        return dom.getBoundingClientRect().x + document.getElementById('zoom').scrollLeft / zoom
    } else {
        return dom.getBoundingClientRect().y + document.getElementById('zoom').scrollTop / zoom
    }
}
/**
 * @function copyBlock 复制积木
 * @param { Number } targetBlockId 积木 id
 */
const copyBlock = (targetBlockId) => {
    let data = getAllChildBlock(targetBlockId)
    let baseId = Number(Object.keys(blocksData)[Object.keys(blocksData).length - 1]) + 1 //Object.keys(blocksData).length+1
    data.unshift(targetBlockId)
    let targetBlockToCopy = document.querySelector(`[blockid="${targetBlockId}"]`)
    let newBlockDom = targetBlockToCopy.cloneNode(true)

    newBlockDom.style.left = setPostiton(targetBlockToCopy, 'x') + 10 + 'px'
    newBlockDom.style.top = setPostiton(targetBlockToCopy, 'y') + 10 + 'px'
    debugger
    codeSpace.appendChild(newBlockDom)
    for (const blockIdToCopy of data) {
        let toCopyData = blocksData[blockIdToCopy]
        blocksData[String(Number(blockIdToCopy) + baseId)] = deepClone(toCopyData)

        let newBlock = blocksData[String(Number(blockIdToCopy) + baseId)]

        let domToQuery = document.createElement("div");
        domToQuery.appendChild(newBlockDom.cloneNode(true))

        let change = (Attribute, AttributeName, callBack = () => { }) => {
            let newBlockDomToChange = newBlockDom.querySelectorAll(Attribute)[0]
            if (!newBlockDomToChange) {
                newBlockDomToChange = newBlockDom
            }
            newBlockDomToChange.setAttribute(AttributeName, String(Number(blockIdToCopy) + baseId))
            callBack(newBlockDomToChange)
        }
        let changeMultiple = (Attribute, AttributeName) => {
            let newBlockDomToChanges = newBlockDom.querySelectorAll(Attribute)
            for (let newBlockDomToChange of newBlockDomToChanges) {
                newBlockDomToChange.setAttribute(AttributeName, String(Number(blockIdToCopy) + baseId))
            }
        }

        if (newBlock.prent) {
            blocksData[String(Number(blockIdToCopy) + baseId)].prent.blockId = String(Number(blocksData[String(Number(blockIdToCopy) + baseId)].prent.blockId) + baseId)
        }

        change(`[blockid="${blockIdToCopy}"]`, 'blockid', (newBlockDomToChange) => {
            let data = blocksData[String(Number(blockIdToCopy) + baseId)]
            if (blockIdToCopy == targetBlockId) {
                newBlockDomToChange.setAttribute('class', 'block')
                dragElement(newBlockDomToChange, connectBlocks)
            } else {
                newBlockDomToChange.onmousedown = (e) => {
                    setDragOut(e, String(Number(blockIdToCopy) + baseId), data.prent.blockId, data.prent.inputId)
                }
            }
            newBlockDomToChange.oncontextmenu = (e) => {
                setContext(e, String(Number(blockIdToCopy) + baseId))
            }
        })
        changeMultiple(`[dragid="${blockIdToCopy}"]`, 'dragid')
        for (const inputKey in newBlock.inputs) {
            changeMultiple(`[prentid="${blockIdToCopy}"][inputId="${inputKey}"]`, 'prentid')
            if (newBlock.inputs[inputKey].value) {
                newBlock.inputs[inputKey].value.data = String(Number(newBlock.inputs[inputKey].value.data) + baseId)
            }
        }
    }
}

/**
 * @function bindEvent 绑定事件
 * @param { object } eventList 事件
 * @param { Number } blockId 积木 id
 * @param { HTMLElement } dom 积木对象
 */
export const bindEvent = (dom, eventList, blockId) => {
    // only for toplevel
    dragElement(dom, connectBlocks)
    dom.oncontextmenu = (e) => {
        setContext(e, blockId)
    }
    for (const aevent of eventList) {
        aevent.selfBlockDom.onmousedown = (e) => {
            setDragOut(e, aevent.selfBlockId, aevent.prentId, aevent.targetBlockInputIndex)
        }
        aevent.selfBlockDom.oncontextmenu = (e) => {
            setContext(e, aevent.selfBlockId)
        }
    }
}

/**
 * @function getBlockById 通过积木Id 获取积木元素
 * @param { Number } tid 积木 id
 * @return { HTMLElement } 积木元素
 */
const getBlockById = (tid) => {
    return document.querySelector(`[blockId="${tid}"]`)
}

/**
 * @function closeMenu 关闭菜单
 */
const closeMenu = () => {
    menuDom.style.display = 'none'
    menu.open = false
}

/**
 * @function init 初始化
 * @param { HTMLElement } codeSpaceDom 工作区元素
 */
export const init = (codeSpaceDom) => {
    menuDom = document.getElementById('menu')
    codeSpace = codeSpaceDom //document.getElementById('app')
    blocksData = {}
    menu = {}

    codeSpace.onmousedown = (e) => {
        if (e.target.getAttribute('id') == 'menuItem') {
            return null;
        }
        closeMenu()
    }

    document.getElementById("menuCopy").addEventListener("click", () => {
        copyBlock(menu.target.data)
        closeMenu()
    })
    document.getElementById("menuDelet").addEventListener("click", () => {
        deletBlock(menu.target.data)
        closeMenu()
    })
}

/**
 * A module that says hello!
 * @exports loadFile
 */
export const loadFile = (projectJson) => {
    file.loadFile(projectJson, blocksData)
}
/**
 * A module that says hello!
 * @exports saveFile
 */
export const saveFile = () => {
    file.saveFile(blocksData)
}
/**
 * @function compile 编译
 * @exports compile 编译
 * @return { compiler }
 */
export const compile = () => {
    return compiler.compile(blocksData)
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-compile%2520%25E7%25BC%2596%25E8%25AF%2591.html">compile 编译</a></li><li><a href="module-loadFile.html">loadFile</a></li><li><a href="module-saveFile.html">saveFile</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addInputBlock">addInputBlock</a></li><li><a href="global.html#bindEvent%25E7%25BB%2591%25E5%25AE%259A%25E4%25BA%258B%25E4%25BB%25B6">bindEvent 绑定事件</a></li><li><a href="global.html#blockMinSpace">blockMinSpace</a></li><li><a href="global.html#blocksData">blocksData</a></li><li><a href="global.html#closeMenu%25E5%2585%25B3%25E9%2597%25AD%25E8%258F%259C%25E5%258D%2595">closeMenu 关闭菜单</a></li><li><a href="global.html#codeSpace">codeSpace</a></li><li><a href="global.html#connectBlocks%25E6%25A3%2580%25E6%259F%25A5%25E7%25A7%25AF%25E6%259C%25A8%25E5%258F%25AF%25E5%2590%25A6%25E8%25BF%259E%25E6%258E%25A5%25E5%2585%25B6%25E4%25BB%2596%25E7%25A7%25AF%25E6%259C%25A8%25E5%25B9%25B6%25E8%25BF%259E%25E6%258E%25A5">connectBlocks 检查积木可否连接其他积木并连接</a></li><li><a href="global.html#copyBlock%25E5%25A4%258D%25E5%2588%25B6%25E7%25A7%25AF%25E6%259C%25A8">copyBlock 复制积木</a></li><li><a href="global.html#createBlockDom%25E5%2588%259B%25E5%25BB%25BA%25E4%25B8%2580%25E4%25B8%25AA%25E7%25A7%25AF%25E6%259C%25A8">createBlockDom 创建一个积木</a></li><li><a href="global.html#createBlockDomById%25E5%2588%259B%25E5%25BB%25BA%25E4%25B8%2580%25E4%25B8%25AA%25E7%25A7%25AF%25E6%259C%25A8">createBlockDomById 创建一个积木</a></li><li><a href="global.html#deletBlock%25E5%2588%25A0%25E9%2599%25A4%25E7%25A7%25AF%25E6%259C%25A8">deletBlock 删除积木</a></li><li><a href="global.html#getAllChildBlock%25E8%258E%25B7%25E5%258F%2596%25E8%25AF%25A5%25E7%25A7%25AF%25E6%259C%25A8%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589%25E5%25AD%2590">getAllChildBlock 获取该积木的所有子</a></li><li><a href="global.html#getBlockById%25E9%2580%259A%25E8%25BF%2587%25E7%25A7%25AF%25E6%259C%25A8Id%25E8%258E%25B7%25E5%258F%2596%25E7%25A7%25AF%25E6%259C%25A8%25E5%2585%2583%25E7%25B4%25A0">getBlockById 通过积木Id 获取积木元素</a></li><li><a href="global.html#getMinChild%25E8%258E%25B7%25E5%258F%2596%25E7%25A7%25AF%25E6%259C%25A8%25E8%25BE%2593%25E5%2585%25A5%25E6%25A1%2586%25E7%259A%2584%25E6%259C%2580%25E5%25AD%2590%25E5%2585%2583%25E7%25B4%25A0">getMinChild 获取积木输入框的最子元素</a></li><li><a href="global.html#init%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596">init 初始化</a></li><li><a href="global.html#menu">menu</a></li><li><a href="global.html#menuDom">menuDom</a></li><li><a href="global.html#setContext%25E8%25AE%25BE%25E7%25BD%25AE%25E7%25A7%25AF%25E6%259C%25A8%25E5%258F%25B3%25E9%2594%25AE%25E8%258F%259C%25E5%258D%2595%25E4%25BA%258B%25E4%25BB%25B6">setContext 设置积木右键菜单事件</a></li><li><a href="global.html#setDragOut%25E8%25AE%25BE%25E7%25BD%25AE%25E7%25A7%25AF%25E6%259C%25A8%25E4%25BB%258E%25E7%2588%25B6%25E7%25A7%25AF%25E6%259C%25A8%25E9%2587%258C%25E6%258B%2596%25E5%2587%25BA%25E6%259D%25A5%25E4%25BA%258B%25E4%25BB%25B6">setDragOut 设置积木从父积木里拖出来事件</a></li><li><a href="global.html#setPostiton%25E9%2580%259A%25E8%25BF%2587%25E5%259C%25A8%25E9%25A1%25B5%25E9%259D%25A2%25E7%259A%2584%25E7%25BB%259D%25E5%25AF%25B9%25E4%25BD%258D%25E7%25BD%25AE%25E8%25AE%25BE%25E7%25BD%25AE%25E4%25BD%258D%25E7%25BD%25AE%25E5%2581%258F%25E7%25A7%25BB">setPostiton 通过在页面的绝对位置设置位置偏移</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Sat Feb 04 2023 14:59:57 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
